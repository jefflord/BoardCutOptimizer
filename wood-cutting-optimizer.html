<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wood Cutting Optimizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; display: flex; height: 100vh; overflow: hidden; }
        .sidebar { width: 320px; background: white; border-right: 1px solid #ddd; display: flex; flex-direction: column; overflow-y: auto; position: relative; flex: 0 0 auto; min-width: 240px; max-width: 640px; }
        .sidebar.resizing { user-select: none; cursor: col-resize; }
        .sidebar-resizer { position: absolute; top: 0; right: 0; width: 6px; height: 100%; cursor: col-resize; background: linear-gradient(to right, rgba(0,0,0,0) 0%, rgba(0,123,255,0.15) 100%); opacity: 0; transition: opacity 0.15s; }
        .sidebar:hover .sidebar-resizer, .sidebar.resizing .sidebar-resizer { opacity: 1; }
        .section { border-bottom: 1px solid #eee; }
        .section-header { background: #f8f9fa; padding: 8px 12px; font-weight: 600; font-size: 13px; color: #495057; cursor: pointer; display: flex; align-items: center; justify-content: space-between; }
        .section-header::after { content: '▼'; font-size: 10px; transition: transform 0.2s; }
        .section.collapsed .section-header::after { transform: rotate(-90deg); }
        .section-content { padding: 12px; display: block; }
        .section.collapsed .section-content { display: none; }
        .panel-list { max-height: 200px; overflow-y: auto; }
        .panel-item { display: grid; grid-template-columns: 60px 50px 70px 70px 90px 40px 1fr; gap: 8px; padding: 4px 0; align-items: center; font-size: 12px; border-bottom: 1px solid #f0f0f0; }
        .panel-item:last-child { border-bottom: none; }
        .panel-item input { width: 100%; padding: 2px 4px; border: 1px solid #ddd; border-radius: 2px; font-size: 11px; }
        .panel-item .qty { text-align: center; }
        .panel-item .actions { display: flex; gap: 2px; }
        .btn { background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 2px; font-size: 11px; cursor: pointer; }
        .btn:hover { background: #0056b3; }
        .btn.btn-sm { padding: 2px 4px; font-size: 10px; }
        .btn.btn-danger { background: #dc3545; }
        .btn.btn-danger:hover { background: #c82333; }
        .btn.btn-success { background: #28a745; }
        .add-panel { margin-top: 8px; }
        .stock-sheet-input { display: grid; grid-template-columns: 70px 70px 50px 1fr 58px; gap: 6px; margin-bottom: 8px; justify-content: start; align-items: center; font-size:11px; }
        .stock-sheet-input input { padding: 4px; border: 1px solid #ddd; border-radius: 2px; font-size: 12px; width: 100%; }
        #stockSheetsList { max-height:170px; overflow-y:auto; margin-top:4px; }
        .stock-sheet-row { display:grid; grid-template-columns: 60px 60px 40px 1fr 60px 60px; gap:6px; padding:4px 0; align-items:center; font-size:11px; border-bottom:1px solid #f0f0f0; }
        .stock-sheet-row:last-child { border-bottom:none; }
        .stock-sheet-row input { width:100%; padding:2px 4px; font-size:11px; }
        .sheet-actions { display:flex; gap:4px; }
        .options { display: flex; flex-direction: column; gap: 8px; }
        .option { display: flex; align-items: center; justify-content: space-between; font-size: 12px; }
        .option input[type="number"] { width: 60px; padding: 2px 4px; border: 1px solid #ddd; border-radius: 2px; }
        .toggle { width: 40px; height: 20px; background: #ddd; border-radius: 10px; position: relative; cursor: pointer; }
        .toggle.active { background: #007bff; }
        .toggle::after { content: ''; width: 16px; height: 16px; background: white; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: left 0.2s; }
        .toggle.active::after { left: 22px; }
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .canvas-container { flex: 1; position: relative; overflow: auto; background: white; padding: 20px; }
        .cutting-board { display:none; }
        #cuttingBoardsContainer { display:flex; flex-wrap:wrap; gap:40px; align-items:flex-start; position:relative; padding:10px; }
        .sheet-board { border: 2px solid #333; background: #f8f9fa; position: relative; min-width: 0; min-height: 0; box-sizing: content-box; overflow: hidden; }
        .sheet-label { position:absolute; top:2px; left:4px; background:rgba(0,0,0,0.55); color:#fff; padding:2px 6px; font-size:11px; border-radius:3px; pointer-events:none; font-weight:600; letter-spacing:.5px; }
        .cut-piece { position: absolute; border: 1px solid #555; background: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 11px; font-weight: 500; cursor: move; user-select: none; box-sizing: border-box; }
        .cut-piece:nth-child(odd) { background: rgba(220, 230, 255, 0.7); }
        .cut-piece:nth-child(even) { background: rgba(255, 220, 220, 0.7); }
        .cut-piece.selected { border-color: #ff9800; box-shadow: 0 0 0 2px rgba(255,152,0,0.35); }
        .cut-piece.dragging { opacity: 0.5; z-index: 1000; }
        .cut-piece .dimensions { font-weight: bold; margin-bottom: 2px; }
        .cut-piece .label { font-size: 10px; color: #666; }
        .stats-panel { position: absolute; top: 20px; right: 20px; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 12px; min-width: 200px; font-size: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .stats-panels { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 10; }
        .stats-panels .stats-panel { position: static; top: auto; right: auto; }
        .stats-panel h4 { margin-bottom: 8px; color: #495057; font-size: 13px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .optimize-btn { position: absolute; bottom: 20px; right: 20px; background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .optimize-btn:hover { background: #218838; }
        .waste-area { background: rgba(255, 0, 0, 0.1) !important; border: 1px dashed #ff0000 !important; }
        .dragging-over { background: rgba(0, 123, 255, 0.1) !important; }
        .panel-headers { display: grid; grid-template-columns: 60px 50px 64px 64px 90px 40px 1fr; gap: 8px; font-weight: 600; font-size: 11px; color: #666; padding: 4px 0; border-bottom: 1px solid #ddd; margin-bottom: 8px; min-width: 480px; }
        .fraction-cell { font-size: 11px; color: #444; font-family: 'Segoe UI', Roboto, sans-serif; padding: 2px 0; line-height: 1.1; white-space: nowrap; }
        .zoom-controls { position: absolute; right: 20px; bottom: 100px; top: auto; left: auto; transform: none; background: white; border: 1px solid #ddd; border-radius: 6px; padding: 10px 8px; display: flex; flex-direction: column; align-items: center; gap: 8px; font-size: 11px; box-shadow: 0 2px 4px rgba(0,0,0,0.12); z-index: 20; }
        .zoom-controls #zoomPercent { font-weight: 600; }
        .zoom-controls button { width: 100%; }
        .zoom-controls input[type=range].vertical-range { writing-mode: bt-lr; appearance: slider-vertical; -webkit-appearance: slider-vertical; width: 8px; height: 180px; padding: 0; }
        @supports not (-webkit-appearance: slider-vertical) { .zoom-controls input[type=range].vertical-range { appearance: none; -webkit-appearance: none; transform: rotate(-90deg); width: 180px; height: 8px; } }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-resizer" id="sidebarResizer" title="Drag to resize sidebar"></div>
        <div class="section">
            <div class="section-header">📋 Panels</div>
            <div class="section-content">
                <div class="panel-headers">
                    <div>Length</div>
                    <div>Width</div>
                    <div>Fraction L</div>
                    <div>Fraction W</div>
                    <div>Label</div>
                    <div>Qty</div>
                    <div></div>
                </div>
                <div class="panel-list" id="panelList"></div>
                <div class="add-panel">
                    <div style="display: grid; grid-template-columns: 60px 50px 90px 40px 1fr; gap: 8px; margin-bottom: 8px;">
                        <input type="number" id="newLength" placeholder="24" step="0.01">
                        <input type="number" id="newWidth" placeholder="9.74" step="0.01">
                        <input type="text" id="newLabel" placeholder="Label" title="Optional label shown on layout">
                        <input type="number" id="newQty" placeholder="1" min="1">
                        <button class="btn" onclick="addPanel()">Add Panel</button>
                    </div>
                    <!-- Import Panels Toggle & Container -->
                    <div style="margin-top:8px;">
                        <button class="btn btn-sm" onclick="toggleImportPanel()" title="Paste structured text to add multiple panels">Import / Paste Panels</button>
                        <div id="panelImportContainer" style="display:none; margin-top:8px; border:1px solid #ddd; padding:8px; background:#fafafa; border-radius:4px;">
                            <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:4px; font-size:11px;">
                                <label for="panelImportFormat" style="font-weight:600;">Format:</label>
                                <select id="panelImportFormat" style="font-size:11px; padding:2px 4px;">
                                    <option value="subbox">SubBox</option>
                                </select>
                                <button class="btn btn-sm" onclick="parsePanelImport()" title="Parse the pasted data">Parse</button>
                                <button class="btn btn-sm btn-success" id="applyImportedBtn" onclick="applyImportedPanels()" disabled title="Add parsed panels to the current list">Add Parsed Panels</button>
                                <button class="btn btn-sm btn-danger" onclick="toggleImportPanel(true)" title="Close importer">Close</button>
                            </div>
                            <textarea id="panelImportInput" style="width:100%; height:110px; font-size:11px; font-family:Consolas, monospace; resize:vertical; padding:4px; border:1px solid #ccc;" placeholder="Paste SubBox data here...&#10;Detail\tSize\tQuantity&#10;Top / Bottom\t24.00&quot; × 15.43&quot;\t2&#10;Front\t20.81&quot; × 9.50&quot;\t1"></textarea>
                            <div id="panelImportMessages" style="margin-top:6px; font-size:11px; color:#555; line-height:1.3;"></div>
                            <div style="margin-top:6px; font-size:10px; color:#777;">
                                Expected SubBox format: Detail<TAB>Size<TAB>Quantity where Size is L × W in inches (quotes optional). Parsed panels are appended; existing list is preserved.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="section">
            <div class="section-header">📦 Stock Sheets</div>
            <div class="section-content">
                <div style="font-size:11px; color:#555; margin-bottom:6px; line-height:1.3;">Add multiple sheet types with quantities. Order determines usage (arrows). Pieces spill to later sheets automatically.</div>
                <div class="stock-sheet-input">
                    <input type="number" id="stockLength" placeholder="L" value="96" step="0.01" title="Sheet length">
                    <input type="number" id="stockWidth" placeholder="W" value="48" step="0.01" title="Sheet width">
                    <input type="number" id="stockQty" placeholder="Qty" value="1" min="1" step="1" title="Quantity">
                    <input type="text" id="stockLabel" placeholder="Label" title="Optional label used for display">
                    <button class="btn btn-sm" onclick="addStockSheetDefinition()" title="Add sheet definition">Add</button>
                </div>
                <div id="stockSheetsList"></div>
            </div>
        </div>
        <div class="section">
            <div class="section-header">⚙️ Options</div>
            <div class="section-content">
                <div class="options">
                    <div class="option"><span>Cut/blade/kerf thickness</span><input type="number" id="kerfThickness" value="0.25" step="0.01"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="main-content">
        <div class="canvas-container">
            <div id="cuttingBoardsContainer"></div>
            <div class="zoom-controls">
                <div id="zoomPercent">100%</div>
                <input class="vertical-range" type="range" id="zoomSlider" min="25" max="300" value="100" step="5" title="Zoom the layout">
                <button class="btn btn-sm" id="zoomResetBtn" title="Reset zoom to 100%">Reset</button>
            </div>
            <div class="stats-panels">
                <div class="stats-panel" id="globalStatsPanel">
                    <h4>Global Statistics</h4>
                    <div class="stat-row"><span>Used stock sheets</span><span id="usedSheets">0</span></div>
                    <div class="stat-row"><span>Total used area</span><span id="totalUsed">0</span></div>
                    <div class="stat-row"><span>Total wasted area</span><span id="totalWasted">0</span></div>
                    <div class="stat-row"><span>Total cuts</span><span id="totalCuts">0</span></div>
                    <div class="stat-row"><span>Optimization priority</span><span>Least wasted area</span></div>
                </div>
                <div class="stats-panel" id="panelDetailsPanel">
                    <h4>Panel Details</h4>
                    <div id="panelDetailsContent" style="font-size:11px; color:#666;">Select a panel on the layout.</div>
                </div>
            </div>
            <button class="optimize-btn" onclick="optimizeCutting()">Optimize Layout</button>
        </div>
    </div>
    <script>
        // Global state
        let panels = [];
        // Stock sheet definitions (each with qty, label). Expanded instances built per optimize run.
        let stockSheets = [{ length: 96, width: 48, qty: 1, label: '' }];
        let expandedSheets = [];
        let placedPieces = [];
        let draggedElement = null;
        let dragOffset = { x: 0, y: 0 };
        let isResizingSidebar = false;
        // Zoom/base scale
        let baseScale = 1;
        let userZoom = 1;
        // Selected piece element
        let selectedPieceEl = null;
        const STORAGE_KEY = 'woodCuttingOptimizerState_v1';

        function getKerfValue() {
            const raw = parseFloat(document.getElementById('kerfThickness').value);
            return isNaN(raw) ? 0.25 : raw;
        }
        function saveState() {
            try {
                const state = { version: 2, panels: panels.map(p => ({ length:+p.length, width:+p.width, qty:+p.qty, label:p.label||'' })), stockSheets: stockSheets.map(s => ({ length:+s.length, width:+s.width, qty:+s.qty, label:s.label||'' })), kerf: getKerfValue(), zoom: userZoom };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) { console.warn('Failed to save state', e); }
        }
        function loadState() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return false;
                const state = JSON.parse(raw);
                if (!state || typeof state !== 'object') return false;
                if (Array.isArray(state.panels)) { panels = state.panels.filter(p => p && p.length > 0 && p.width > 0 && p.qty > 0).map(p => ({...p, label: p.label || ''})); }
                if (Array.isArray(state.stockSheets)) {
                    stockSheets = state.stockSheets.filter(s => s && s.length>0 && s.width>0 && (s.qty||1)>0).map(s => ({ length:+s.length, width:+s.width, qty:+(s.qty||1), label:s.label||'' }));
                } else if (state.stockSheet && state.stockSheet.length>0 && state.stockSheet.width>0) { // backwards compat v1
                    stockSheets = [{ length:+state.stockSheet.length, width:+state.stockSheet.width, qty:1, label:'' }];
                }
                if (state.kerf !== undefined) { document.getElementById('kerfThickness').value = +state.kerf; }
                if (state.zoom && typeof state.zoom === 'number') { userZoom = state.zoom; const slider = document.getElementById('zoomSlider'); if (slider) slider.value = Math.round(userZoom * 100); }
                return true;
            } catch (e) { console.warn('Failed to load saved state', e); return false; }
        }
        (function initSidebarResize() { const sidebar = document.getElementById('sidebar'); const handle = document.getElementById('sidebarResizer'); const saved = localStorage.getItem('sidebarWidth'); if (saved) { const w = parseInt(saved, 10); if (!isNaN(w)) sidebar.style.width = w + 'px'; } const minW = 240; const maxW = 640; const onMouseMove = (e) => { if (!isResizingSidebar) return; const newWidth = Math.min(maxW, Math.max(minW, e.clientX)); sidebar.style.width = newWidth + 'px'; }; const onMouseUp = () => { if (isResizingSidebar) { isResizingSidebar = false; sidebar.classList.remove('resizing'); localStorage.setItem('sidebarWidth', parseInt(sidebar.getBoundingClientRect().width, 10)); window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); } }; handle.addEventListener('mousedown', (e) => { e.preventDefault(); isResizingSidebar = true; sidebar.classList.add('resizing'); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp); }); })();
        (function init() { const loaded = loadState(); if (!loaded) { const defaultPanels = [ { length: 24, width: 14.62, qty: 2, label: 'Panel A' }, { length: 20.98, width: 9.74, qty: 1, label: 'Panel B' }, { length: 24, width: 9.74, qty: 1, label: 'Panel C' }, { length: 13.36, width: 9.74, qty: 1, label: 'Panel D' }, { length: 13.99, width: 9.74, qty: 1, label: 'Panel E' }, { length: 10.97, width: 9.74, qty: 1, label: 'Panel F' }, { length: 14.18, width: 9.74, qty: 1, label: 'Panel G' } ]; panels = defaultPanels.slice(); }
            renderPanels(); renderStockSheets(); optimizeCutting(); updateZoom(); })();

        function addPanel() { const lengthInput = document.getElementById('newLength'); const widthInput = document.getElementById('newWidth'); const labelInput = document.getElementById('newLabel'); const qtyInput = document.getElementById('newQty'); const length = parseFloat(lengthInput.value || lengthInput.placeholder); const width = parseFloat(widthInput.value || widthInput.placeholder); const qty = parseInt(qtyInput.value || qtyInput.placeholder || '1') || 1; const label = (labelInput.value || '').trim(); if (!isNaN(length) && !isNaN(width) && length > 0 && width > 0) { panels.push({ length, width, qty, label }); renderPanels(); optimizeCutting(); saveState(); lengthInput.value=''; widthInput.value=''; labelInput.value=''; qtyInput.value='1'; } else { console.warn('Panel not added: provide valid numeric length & width.'); } }
        function removePanel(index) { panels.splice(index, 1); renderPanels(); optimizeCutting(); saveState(); }
        function renderPanels() { const container = document.getElementById('panelList'); container.innerHTML=''; panels.forEach((panel, index) => { const div = document.createElement('div'); div.className = 'panel-item'; const fracL = toSixteenthFraction(panel.length); const fracW = toSixteenthFraction(panel.width); div.innerHTML = `
                    <input type="number" value="${panel.length}" onchange="updatePanel(${index}, 'length', this.value)" step="0.01" title="Decimal length">
                    <input type="number" value="${panel.width}" onchange="updatePanel(${index}, 'width', this.value)" step="0.01" title="Decimal width">
                    <div class="fraction-cell" data-panel-index="${index}" data-fraction-type="L" title="Nearest 1/16\"">${fracL}</div>
                    <div class="fraction-cell" data-panel-index="${index}" data-fraction-type="W" title="Nearest 1/16\"">${fracW}</div>
                    <input type="text" value="${panel.label || ''}" onchange="updatePanel(${index}, 'label', this.value)" placeholder="Label" title="Label shown on layout">
                    <input type="number" value="${panel.qty}" onchange="updatePanel(${index}, 'qty', this.value)" min="1" class="qty">
                    <div class="actions"><button class="btn btn-sm btn-danger" onclick="removePanel(${index})" title="Remove">✕</button></div>`; container.appendChild(div); }); }
        function toSixteenthFraction(value) { if (isNaN(value)) return ''; const inches = Math.floor(value); const remainder = value - inches; let sixteenths = Math.round(remainder * 16); if (sixteenths === 16) { return (inches + 1).toString(); } if (sixteenths === 0) return inches.toString(); const gcd = (a,b)=> b ? gcd(b, a%b) : a; const g = gcd(sixteenths, 16); const num = sixteenths / g; const den = 16 / g; return inches > 0 ? `${inches} ${num}/${den}` : `${num}/${den}`; }
        function updatePanel(index, field, value) { if (field === 'qty') { panels[index][field] = parseInt(value) || 1; } else if (field === 'label') { panels[index].label = (value || '').trim(); updateRenderedPieceLabels(); } else { panels[index][field] = parseFloat(value) || 0; updatePanelFractions(index); } saveState(); optimizeCutting(); }
        function updatePanelFractions(index) { const panel = panels[index]; if (!panel) return; const fracL = toSixteenthFraction(panel.length); const fracW = toSixteenthFraction(panel.width); const lCell = document.querySelector(`.fraction-cell[data-panel-index="${index}"][data-fraction-type="L"]`); const wCell = document.querySelector(`.fraction-cell[data-panel-index="${index}"][data-fraction-type="W"]`); if (lCell) lCell.textContent = fracL; if (wCell) wCell.textContent = fracW; }

        // Stock sheet definitions UI
        function addStockSheetDefinition() { const length = parseFloat(document.getElementById('stockLength').value); const width = parseFloat(document.getElementById('stockWidth').value); const qty = parseInt(document.getElementById('stockQty').value,10)||1; const label = (document.getElementById('stockLabel').value||'').trim(); if (length>0 && width>0 && qty>0) { stockSheets.push({ length, width, qty, label }); renderStockSheets(); optimizeCutting(); saveState(); } }
        function renderStockSheets() { const list = document.getElementById('stockSheetsList'); if (!list) return; list.innerHTML=''; stockSheets.forEach((s, index) => { const row = document.createElement('div'); row.className='stock-sheet-row'; row.innerHTML = `
                <input type="number" value="${s.length}" step="0.01" title="Length" onchange="updateStockSheet(${index},'length',this.value)">
                <input type="number" value="${s.width}" step="0.01" title="Width" onchange="updateStockSheet(${index},'width',this.value)">
                <input type="number" value="${s.qty}" min="1" step="1" title="Quantity" onchange="updateStockSheet(${index},'qty',this.value)">
                <input type="text" value="${s.label||''}" placeholder="Label" title="Label" onchange="updateStockSheet(${index},'label',this.value)">
                <div class="sheet-actions">
                    <button class="btn btn-sm" title="Move up" onclick="moveStockSheet(${index},-1)" ${index===0?'disabled':''}>↑</button>
                    <button class="btn btn-sm" title="Move down" onclick="moveStockSheet(${index},1)" ${index===stockSheets.length-1?'disabled':''}>↓</button>
                </div>
                <div class="sheet-actions">
                    <button class="btn btn-sm btn-danger" title="Remove" onclick="removeStockSheet(${index})">✕</button>
                </div>`; list.appendChild(row); }); }
        function updateStockSheet(index, field, value) { if (!stockSheets[index]) return; if (field==='qty') { stockSheets[index].qty = Math.max(1, parseInt(value,10)||1); } else if (field==='label') { stockSheets[index].label = (value||'').trim(); } else { stockSheets[index][field] = parseFloat(value)||0; } saveState(); optimizeCutting(); }
        function moveStockSheet(index, dir) { const newIndex = index + dir; if (newIndex<0 || newIndex>=stockSheets.length) return; const [it] = stockSheets.splice(index,1); stockSheets.splice(newIndex,0,it); renderStockSheets(); optimizeCutting(); saveState(); }
        function removeStockSheet(index) { stockSheets.splice(index,1); renderStockSheets(); optimizeCutting(); saveState(); }
        function expandSheets() { const result=[]; stockSheets.forEach(def => { for (let i=0;i<def.qty;i++) { const seq = result.length+1; const label = def.label ? (def.qty>1 ? `${def.label} #${i+1}` : def.label) : `Sheet ${seq}`; result.push({ length:def.length, width:def.width, label, defIndex: stockSheets.indexOf(def), instanceIndex:i }); } }); return result; }
        function computeBaseScale(sheets) { if (!sheets.length) { baseScale=1; return; } const maxL = Math.max(...sheets.map(s=>s.length)); const maxW = Math.max(...sheets.map(s=>s.width)); const maxWidth = 700; const maxHeight = 500; baseScale = Math.min(maxWidth / maxL, maxHeight / maxW); }
        function updateCuttingBoardsSizing() { const scale = baseScale * userZoom; document.querySelectorAll('.sheet-board').forEach(board => { const idx = parseInt(board.dataset.sheetIndex,10); const sheet = expandedSheets[idx]; if (!sheet) return; board.style.width = (sheet.length * scale) + 'px'; board.style.height = (sheet.width * scale) + 'px'; }); }

        function toggleOption(element) { element.classList.toggle('active'); }

        function optimizeCutting() {
            const container = document.getElementById('cuttingBoardsContainer');
            if (!container) return;
            expandedSheets = expandSheets();
            computeBaseScale(expandedSheets);
            const scale = baseScale * userZoom;
            const kerf = getKerfValue();
            container.innerHTML='';
            placedPieces = [];
            selectedPieceEl = null;
            const detailsContent = document.getElementById('panelDetailsContent');
            if (detailsContent) detailsContent.textContent = 'Select a panel on the layout.';
            // Create boards
            expandedSheets.forEach((sheet, sheetIndex) => {
                const board = document.createElement('div');
                board.className='sheet-board';
                board.dataset.sheetIndex=sheetIndex;
                board.style.width = (sheet.length * scale) + 'px';
                board.style.height = (sheet.width * scale) + 'px';
                board.innerHTML = `<div class="sheet-label">${escapeHtml(sheet.label)}</div>`;
                attachBoardDragEvents(board);
                container.appendChild(board);
            });
            // Build piece list
            const allPieces = [];
            panels.forEach((panel, panelIndex) => {
                for (let i=0;i<panel.qty;i++) {
                    allPieces.push({ length: panel.length, width: panel.width, panelIndex, label: panel.label||'', id: `piece_${panelIndex}_${i}` });
                }
            });
            allPieces.sort((a,b)=> (b.length*b.width)-(a.length*a.width));
            const placedRects = [];
            allPieces.forEach(piece => {
                for (let sIdx=0; sIdx<expandedSheets.length; sIdx++) {
                    const sheet = expandedSheets[sIdx];
                    const existing = placedRects.filter(r=>r.sheetIndex===sIdx);
                    const pos = findBestPositionMulti(piece, existing, sheet, kerf);
                    if (pos) {
                        const rect = { x:pos.x, y:pos.y, length:piece.length, width:piece.width, piece, sheetIndex:sIdx };
                        placedRects.push(rect);
                        const board = container.querySelector(`.sheet-board[data-sheet-index="${sIdx}"]`);
                        if (board) createPieceElement(rect, scale, board);
                        return; // proceed to next piece
                    }
                }
                // If we reach here, piece did not fit any sheet (currently just skipped)
            });
            updateStatsMulti(placedRects, expandedSheets);
            saveState();
        }
        function findBestPositionMulti(piece, placedRectsOnSheet, sheet, kerf) { const positions=[{x:0,y:0}]; placedRectsOnSheet.forEach(rect=>{ positions.push({x:rect.x+rect.length+kerf,y:rect.y}); positions.push({x:rect.x,y:rect.y+rect.width+kerf}); positions.push({x:rect.x+rect.length+kerf,y:rect.y+rect.width+kerf}); }); positions.sort((a,b)=> a.y===b.y? a.x-b.x : a.y-b.y); for (const pos of positions) { if (canPlacePieceMulti(piece,pos.x,pos.y,placedRectsOnSheet,sheet,kerf)) return pos; const rotated={length:piece.width,width:piece.length}; if (canPlacePieceMulti(rotated,pos.x,pos.y,placedRectsOnSheet,sheet,kerf)) { piece.length=rotated.length; piece.width=rotated.width; return pos; } } return null; }
        function canPlacePieceMulti(piece,x,y,placedRectsOnSheet,sheet,kerf){ if (x+piece.length>sheet.length || y+piece.width>sheet.width) return false; for (const rect of placedRectsOnSheet){ if (!(x >= rect.x + rect.length + kerf || x + piece.length + kerf <= rect.x || y >= rect.y + rect.width + kerf || y + piece.width + kerf <= rect.y)) return false; } return true; }
        function createPieceElement(rect, scale, container) { const element = document.createElement('div'); element.className='cut-piece'; element.id = rect.piece.id; element.style.left = (rect.x * scale) + 'px'; element.style.top = (rect.y * scale) + 'px'; element.style.width = (rect.length * scale) + 'px'; element.style.height = (rect.width * scale) + 'px'; element.dataset.xInches=rect.x; element.dataset.yInches=rect.y; element.dataset.length=rect.length; element.dataset.width=rect.width; element.dataset.sheetIndex=rect.sheetIndex; element.innerHTML = `<div class=\"dimensions\">${rect.length} × ${rect.width}</div><div class=\"label\">${rect.piece.label ? escapeHtml(rect.piece.label) : 'Panel ' + (rect.piece.panelIndex + 1)}</div>`; element.draggable=true; element.addEventListener('dragstart',handleDragStart); element.addEventListener('dragend',handleDragEnd); element.addEventListener('click',()=>selectPiece(element)); container.appendChild(element); }
        function attachBoardDragEvents(board){ board.addEventListener('dragover', e=>{ e.preventDefault(); board.classList.add('dragging-over'); }); board.addEventListener('dragleave', e=>{ if (e.currentTarget===board) board.classList.remove('dragging-over'); }); board.addEventListener('drop', e=>{ e.preventDefault(); board.classList.remove('dragging-over'); if (draggedElement){ const scale = baseScale * userZoom; const r = board.getBoundingClientRect(); const newX = e.clientX - r.left - dragOffset.x; const newY = e.clientY - r.top - dragOffset.y; const maxX = board.clientWidth - draggedElement.offsetWidth; const maxY = board.clientHeight - draggedElement.offsetHeight; const cx = Math.max(0, Math.min(newX, maxX)); const cy = Math.max(0, Math.min(newY, maxY)); draggedElement.style.left = cx + 'px'; draggedElement.style.top = cy + 'px'; draggedElement.dataset.sheetIndex = board.dataset.sheetIndex; draggedElement.dataset.xInches=(cx/scale).toFixed(4); draggedElement.dataset.yInches=(cy/scale).toFixed(4); if (selectedPieceEl===draggedElement) updatePanelDetailsFromElement(draggedElement); } }); }
        function handleDragStart(e) { draggedElement = e.target; e.target.classList.add('dragging'); const elementRect = e.target.getBoundingClientRect(); dragOffset.x = e.clientX - elementRect.left; dragOffset.y = e.clientY - elementRect.top; }
        function handleDragEnd(e) { if (draggedElement) { draggedElement.classList.remove('dragging'); const scale = baseScale * userZoom; const newXpx = parseFloat(draggedElement.style.left) || 0; const newYpx = parseFloat(draggedElement.style.top) || 0; draggedElement.dataset.xInches = (newXpx / scale).toFixed(4); draggedElement.dataset.yInches = (newYpx / scale).toFixed(4); if (selectedPieceEl === draggedElement) { updatePanelDetailsFromElement(draggedElement); } draggedElement = null; } }
        function escapeHtml(str) { return str.replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'})); }
        function updateRenderedPieceLabels() { panels.forEach((p, panelIndex) => { const labels = document.querySelectorAll(`.cut-piece[id^="piece_${panelIndex}_"] .label`); labels.forEach(el => { el.textContent = p.label ? p.label : `Panel ${panelIndex + 1}`; }); }); if (selectedPieceEl) updatePanelDetailsFromElement(selectedPieceEl); }
        function updateStatsMulti(placedRects, sheets) { const usedSheetsSet = new Set(placedRects.map(r=>r.sheetIndex)); const usedSheets = sheets.filter((_,idx)=>usedSheetsSet.has(idx)); const usedArea = placedRects.reduce((sum, rect) => sum + (rect.length * rect.width), 0); const totalAreaUsedSheets = usedSheets.reduce((sum,s)=> sum + s.length * s.width, 0); const wastedArea = totalAreaUsedSheets - usedArea; const efficiency = totalAreaUsedSheets>0 ? (usedArea/totalAreaUsedSheets*100).toFixed(1) : '0.0'; document.getElementById('usedSheets').textContent = usedSheets.length; document.getElementById('totalUsed').textContent = `${usedArea.toFixed(2)} (${efficiency}%)`; document.getElementById('totalWasted').textContent = `${wastedArea.toFixed(2)} (${totalAreaUsedSheets>0?(100-parseFloat(efficiency)).toFixed(1):'0.0'}%)`; document.getElementById('totalCuts').textContent = placedRects.length; }
        document.addEventListener('click', e => { if (e.target.classList.contains('section-header')) { e.target.parentElement.classList.toggle('collapsed'); } });
        document.addEventListener('keypress', e => { if (e.key === 'Enter' && (e.target.id === 'newLength' || e.target.id === 'newWidth' || e.target.id === 'newQty' || e.target.id === 'newLabel')) { addPanel(); } });
        document.getElementById('kerfThickness').addEventListener('change', () => { saveState(); optimizeCutting(); });
        document.getElementById('zoomSlider').addEventListener('input', (e) => { userZoom = parseInt(e.target.value, 10) / 100; updateZoom(); saveState(); });
        document.getElementById('zoomResetBtn').addEventListener('click', () => { userZoom = 1; const slider = document.getElementById('zoomSlider'); slider.value = 100; updateZoom(); saveState(); });
        function updateZoom() { updateCuttingBoardsSizing(); const scale = baseScale * userZoom; document.querySelectorAll('.cut-piece').forEach(el => { const len = parseFloat(el.dataset.length); const wid = parseFloat(el.dataset.width); const xIn = parseFloat(el.dataset.xInches); const yIn = parseFloat(el.dataset.yInches); if (!isNaN(len) && !isNaN(wid) && !isNaN(xIn) && !isNaN(yIn)) { el.style.width = (len * scale) + 'px'; el.style.height = (wid * scale) + 'px'; el.style.left = (xIn * scale) + 'px'; el.style.top = (yIn * scale) + 'px'; } }); const pct = Math.round(userZoom*100); document.getElementById('zoomPercent').textContent = pct + '%'; if (selectedPieceEl) updatePanelDetailsFromElement(selectedPieceEl); }
        function selectPiece(el) { if (selectedPieceEl === el) return; if (selectedPieceEl) selectedPieceEl.classList.remove('selected'); selectedPieceEl = el; el.classList.add('selected'); updatePanelDetailsFromElement(el); }
        function updatePanelDetailsFromElement(el) { if (!el) return; const sheetIndex = parseInt(el.dataset.sheetIndex,10); const sheet = expandedSheets[sheetIndex] || {length:0,width:0,label:'?'}; const length = parseFloat(el.dataset.length) || 0; const width = parseFloat(el.dataset.width) || 0; const x = parseFloat(el.dataset.xInches) || 0; const y = parseFloat(el.dataset.yInches) || 0; const sheetLen = sheet.length; const sheetWid = sheet.width; const rightEdgeX = x + length; const bottomEdgeY = y + width; const leftSide_toSheetLeft = x; const leftSide_toSheetRight = sheetLen - x; const rightSide_toSheetLeft = rightEdgeX; const rightSide_toSheetRight = sheetLen - rightEdgeX; const topSide_toSheetTop = y; const topSide_toSheetBottom = sheetWid - y; const bottomSide_toSheetTop = bottomEdgeY; const bottomSide_toSheetBottom = sheetWid - bottomEdgeY; const area = length * width; const labelEl = el.querySelector('.label'); const label = labelEl ? labelEl.textContent : ''; const details = document.getElementById('panelDetailsContent'); if (!details) return; const fmt = v => (isFinite(v) ? v.toFixed(2) : '—'); details.innerHTML = `<div style="margin-bottom:6px;font-weight:600;color:#333;">${escapeHtml(label)}</div>
                <div style="display:grid;grid-template-columns:140px 1fr 1fr;row-gap:3px;column-gap:8px;align-items:center;">
                    <div style='font-weight:600;'>Metric</div><div style='font-weight:600;'>Distance A</div><div style='font-weight:600;'>Distance B</div>
                    <div>Length</div><div colspan='2' style='grid-column: span 2;'>${fmt(length)}</div>
                    <div>Width</div><div colspan='2' style='grid-column: span 2;'>${fmt(width)}</div>
                    <div>Area</div><div colspan='2' style='grid-column: span 2;'>${fmt(area)}</div>
                    <div>Left → Left / Right</div><div>${fmt(leftSide_toSheetLeft)}</div><div>${fmt(leftSide_toSheetRight)}</div>
                    <div>Right → Left / Right</div><div>${fmt(rightSide_toSheetLeft)}</div><div>${fmt(rightSide_toSheetRight)}</div>
                    <div>Top → Top / Bottom</div><div>${fmt(topSide_toSheetTop)}</div><div>${fmt(topSide_toSheetBottom)}</div>
                    <div>Bottom → Top / Bottom</div><div>${fmt(bottomSide_toSheetTop)}</div><div>${fmt(bottomSide_toSheetBottom)}</div>
                </div>
                <div style="margin-top:6px;font-size:10px;color:#555;">On sheet: ${escapeHtml(sheet.label||'')}</div>`; }
        // ========= Panel Import Feature =========
        let importedPanelsBuffer = [];
        function toggleImportPanel(closeOnly) { const container = document.getElementById('panelImportContainer'); if (!container) return; if (closeOnly) { container.style.display='none'; return; } container.style.display = container.style.display === 'none' ? 'block' : 'none'; if (container.style.display === 'block') { document.getElementById('panelImportInput').focus(); } else { clearImportState(); } }
        function clearImportState() { importedPanelsBuffer = []; const msg = document.getElementById('panelImportMessages'); if (msg) msg.innerHTML=''; const applyBtn = document.getElementById('applyImportedBtn'); if (applyBtn) applyBtn.disabled = true; }
        function parsePanelImport() { const format = (document.getElementById('panelImportFormat')?.value || 'subbox').toLowerCase(); const raw = document.getElementById('panelImportInput').value.trim(); clearImportState(); if (!raw) { setImportMessage('Paste data first.', 'warn'); return; } let parsed = []; if (format === 'subbox') { parsed = parseSubBoxFormat(raw); } else { setImportMessage('Unknown format selected.', 'error'); return; } if (!parsed.length) { setImportMessage('No valid panel rows parsed.', 'error'); return; } importedPanelsBuffer = parsed; setImportMessage(`Parsed ${parsed.length} panel${parsed.length!==1?'s':''}. Review then click "Add Parsed Panels".`, 'ok'); const applyBtn = document.getElementById('applyImportedBtn'); if (applyBtn) applyBtn.disabled = false; }
        function setImportMessage(text, type) { const msg = document.getElementById('panelImportMessages'); if (!msg) return; const colors = { ok: '#155724', warn: '#856404', error: '#721c24' }; const bgs = { ok: '#d4edda', warn: '#fff3cd', error: '#f8d7da' }; msg.style.background = bgs[type] || '#eee'; msg.style.padding = '4px 6px'; msg.style.borderRadius = '3px'; msg.style.border = '1px solid rgba(0,0,0,0.08)'; msg.style.color = colors[type] || '#333'; msg.textContent = text; }
        function parseSubBoxFormat(text) { const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0); if (!lines.length) return []; if (/\bSize\b/i.test(lines[0]) && /\bQuantity\b/i.test(lines[0])) { lines.shift(); } const results = []; const sizeRegex = /([0-9]+(?:\.[0-9]+)?)\s*(?:"|in|inch|in\.)?\s*[×x]\s*([0-9]+(?:\.[0-9]+)?)\s*(?:"|in|inch|in\.)?/i; lines.forEach(line => { const cols = line.split(/\t+/); if (cols.length < 3) { if (line.includes('×') || line.toLowerCase().includes('x')) { const m = sizeRegex.exec(line); if (m) { const qtyMatch = line.trim().match(/(\d+)\s*$/); const qty = qtyMatch ? parseInt(qtyMatch[1],10) : 1; const detail = line.slice(0, m.index).trim().replace(/\s{2,}/g,' '); const length = parseFloat(m[1]); const width = parseFloat(m[2]); if (isFinite(length) && isFinite(width) && qty>0) { results.push({ length, width, qty, label: detail }); } } } return; } const detail = cols[0].trim(); const sizeStr = cols[1].trim(); const qtyStr = cols[2].trim(); const m = sizeRegex.exec(sizeStr); if (!m) return; const length = parseFloat(m[1]); const width = parseFloat(m[2]); let qty = parseInt(qtyStr,10); if (!isFinite(qty) || qty <= 0) qty = 1; if (isFinite(length) && isFinite(width) && length>0 && width>0) { results.push({ length, width, qty, label: detail }); } }); return results; }
        function applyImportedPanels() { if (!importedPanelsBuffer.length) { setImportMessage('Nothing to add. Parse first.', 'warn'); return; } importedPanelsBuffer.forEach(p => panels.push(p)); renderPanels(); optimizeCutting(); saveState(); setImportMessage(`Added ${importedPanelsBuffer.length} panel${importedPanelsBuffer.length!==1?'s':''}.`, 'ok'); importedPanelsBuffer = []; const applyBtn = document.getElementById('applyImportedBtn'); if (applyBtn) applyBtn.disabled = true; }
        // =========================================
    </script>
    </body>
    </html>